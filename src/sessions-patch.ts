import { chmod, mkdir, writeFile } from "node:fs/promises";
import { existsSync } from "node:fs";
import { join } from "node:path";

/**
 * Generate sessions browser script (Node.js)
 */
function generateSessionsBrowserScript(aliasName: string): string {
  const aliasJson = JSON.stringify(aliasName);
  return `#!/usr/bin/env node
// Droid Sessions Browser - Interactive selector
// Auto-generated by droid-patch

const fs = require('fs');
const path = require('path');
const readline = require('readline');
const { execSync, spawn } = require('child_process');

const FACTORY_HOME = path.join(require('os').homedir(), '.factory');
const SESSIONS_ROOT = path.join(FACTORY_HOME, 'sessions');
const ALIAS_NAME = ${aliasJson};

// ANSI
const CYAN = '\\x1b[36m';
const GREEN = '\\x1b[32m';
const YELLOW = '\\x1b[33m';
const RED = '\\x1b[31m';
const DIM = '\\x1b[2m';
const RESET = '\\x1b[0m';
const BOLD = '\\x1b[1m';
const CLEAR = '\\x1b[2J\\x1b[H';
const HIDE_CURSOR = '\\x1b[?25l';
const SHOW_CURSOR = '\\x1b[?25h';

function sanitizePath(p) {
  return p.replace(/:/g, '').replace(/[\\\\/]/g, '-');
}

function parseSessionFile(jsonlPath, settingsPath) {
  const sessionId = path.basename(jsonlPath, '.jsonl');
  const stats = fs.statSync(jsonlPath);
  
  const result = {
    id: sessionId,
    title: '',
    mtime: stats.mtimeMs,
    model: '',
    firstUserMsg: '',
    lastUserMsg: '',
    messageCount: 0,
    lastTimestamp: '',
  };

  try {
    const content = fs.readFileSync(jsonlPath, 'utf-8');
    const lines = content.split('\\n').filter(l => l.trim());
    const userMessages = [];
    
    for (const line of lines) {
      try {
        const obj = JSON.parse(line);
        if (obj.type === 'session_start') {
          result.title = obj.title || '';
        } else if (obj.type === 'message') {
          result.messageCount++;
          if (obj.timestamp) result.lastTimestamp = obj.timestamp;
          
          const msg = obj.message || {};
          if (msg.role === 'user' && Array.isArray(msg.content)) {
            for (const c of msg.content) {
              if (c && c.type === 'text' && c.text && !c.text.startsWith('<system-reminder>')) {
                userMessages.push(c.text.slice(0, 150).replace(/\\n/g, ' ').trim());
                break;
              }
            }
          }
        }
      } catch {}
    }
    
    if (userMessages.length > 0) {
      result.firstUserMsg = userMessages[0];
      result.lastUserMsg = userMessages.length > 1 ? userMessages[userMessages.length - 1] : '';
    }
  } catch {}

  if (fs.existsSync(settingsPath)) {
    try {
      const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf-8'));
      result.model = settings.model || '';
    } catch {}
  }

  return result;
}

function collectSessions() {
  const cwd = process.cwd();
  const cwdSanitized = sanitizePath(cwd);
  const sessions = [];

  if (!fs.existsSync(SESSIONS_ROOT)) return sessions;

  for (const wsDir of fs.readdirSync(SESSIONS_ROOT)) {
    if (wsDir !== cwdSanitized) continue;
    
    const wsPath = path.join(SESSIONS_ROOT, wsDir);
    if (!fs.statSync(wsPath).isDirectory()) continue;

    for (const file of fs.readdirSync(wsPath)) {
      if (!file.endsWith('.jsonl')) continue;
      
      const sessionId = file.slice(0, -6);
      const jsonlPath = path.join(wsPath, file);
      const settingsPath = path.join(wsPath, sessionId + '.settings.json');

      try {
        const session = parseSessionFile(jsonlPath, settingsPath);
        if (session.messageCount === 0 || !session.firstUserMsg) continue;
        sessions.push(session);
      } catch {}
    }
  }

  sessions.sort((a, b) => b.mtime - a.mtime);
  return sessions.slice(0, 50);
}

function formatTime(ts) {
  if (!ts) return '';
  try {
    const d = new Date(ts);
    return d.toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
  } catch {
    return ts.slice(0, 16);
  }
}

function truncate(s, len) {
  if (!s) return '';
  s = s.replace(/\\n/g, ' ');
  return s.length > len ? s.slice(0, len - 3) + '...' : s;
}

function render(sessions, selected, offset, rows) {
  const cwd = process.cwd();
  const pageSize = rows - 6;
  const visible = sessions.slice(offset, offset + pageSize);
  
  let out = CLEAR;
  out += BOLD + 'Sessions: ' + RESET + DIM + cwd + RESET + '\\n';
  out += DIM + '[↑/↓] Select  [Enter] Resume  [q] Quit' + RESET + '\\n\\n';

  for (let i = 0; i < visible.length; i++) {
    const s = visible[i];
    const idx = offset + i;
    const isSelected = idx === selected;
    const prefix = isSelected ? GREEN + '▶ ' + RESET : '  ';
    
    const title = truncate(s.title || '(no title)', 35);
    const time = formatTime(s.lastTimestamp);
    const model = truncate(s.model, 20);
    
    if (isSelected) {
      out += prefix + YELLOW + title + RESET + '\\n';
      out += '    ' + DIM + 'ID: ' + RESET + CYAN + s.id + RESET + '\\n';
      out += '    ' + DIM + 'Last: ' + time + ' | Model: ' + model + ' | ' + s.messageCount + ' msgs' + RESET + '\\n';
      out += '    ' + DIM + 'First input: ' + RESET + truncate(s.firstUserMsg, 60) + '\\n';
      if (s.lastUserMsg && s.lastUserMsg !== s.firstUserMsg) {
        out += '    ' + DIM + 'Last input:  ' + RESET + truncate(s.lastUserMsg, 60) + '\\n';
      }
    } else {
      out += prefix + title + DIM + ' (' + time + ')' + RESET + '\\n';
    }
  }

  out += '\\n' + DIM + 'Page ' + (Math.floor(offset / pageSize) + 1) + '/' + Math.ceil(sessions.length / pageSize) + ' (' + sessions.length + ' sessions)' + RESET;
  
  process.stdout.write(out);
}

async function main() {
  const sessions = collectSessions();
  
  if (sessions.length === 0) {
    console.log(RED + 'No sessions with interactions found in current directory' + RESET);
    process.exit(0);
  }

  if (!process.stdin.isTTY) {
    for (const s of sessions) {
      console.log(s.id + '  ' + (s.title || '') + '  ' + formatTime(s.lastTimestamp));
    }
    process.exit(0);
  }

  const rows = process.stdout.rows || 24;
  const pageSize = rows - 6;
  let selected = 0;
  let offset = 0;

  function restoreTerminal() {
    try { process.stdout.write(SHOW_CURSOR); } catch {}
    try { process.stdin.setRawMode(false); } catch {}
    try { process.stdin.pause(); } catch {}
  }

  function clearScreen() {
    try { process.stdout.write(CLEAR); } catch {}
  }

  process.stdin.setRawMode(true);
  process.stdin.resume();
  process.stdout.write(HIDE_CURSOR);
  
  render(sessions, selected, offset, rows);

  const onKey = (key) => {
    const k = key.toString();
    
    if (k === 'q' || k === '\\x03') { // q or Ctrl+C
      restoreTerminal();
      clearScreen();
      process.exit(0);
    }
    
    if (k === '\\r' || k === '\\n') { // Enter
      // Stop reading input / stop reacting to arrow keys before handing off to droid.
      process.stdin.off('data', onKey);
      restoreTerminal();
      clearScreen();
      const session = sessions[selected];
      console.log(GREEN + 'Resuming session: ' + session.id + RESET);
      console.log(DIM + 'Using: ' + ALIAS_NAME + ' --resume ' + session.id + RESET + '\\n');

      // Avoid the sessions browser reacting to signals while droid is running.
      try { process.removeAllListeners('SIGINT'); } catch {}
      try { process.removeAllListeners('SIGTERM'); } catch {}
      try { process.on('SIGINT', () => {}); } catch {}
      try { process.on('SIGTERM', () => {}); } catch {}

      const child = spawn(ALIAS_NAME, ['--resume', session.id], { stdio: 'inherit' });
      child.on('exit', (code) => process.exit(code || 0));
      child.on('error', () => process.exit(1));
      return;
    }
    
    if (k === '\\x1b[A' || k === 'k') { // Up
      if (selected > 0) {
        selected--;
        if (selected < offset) offset = Math.max(0, offset - 1);
      }
    } else if (k === '\\x1b[B' || k === 'j') { // Down
      if (selected < sessions.length - 1) {
        selected++;
        if (selected >= offset + pageSize) offset++;
      }
    } else if (k === '\\x1b[5~') { // Page Up
      selected = Math.max(0, selected - pageSize);
      offset = Math.max(0, offset - pageSize);
    } else if (k === '\\x1b[6~') { // Page Down
      selected = Math.min(sessions.length - 1, selected + pageSize);
      offset = Math.min(Math.max(0, sessions.length - pageSize), offset + pageSize);
    }
    
    render(sessions, selected, offset, rows);
  };

  process.stdin.on('data', onKey);

  process.on('SIGINT', () => {
    restoreTerminal();
    clearScreen();
    process.exit(0);
  });
}

main();
`;
}

/**
 * Create sessions browser script file
 */
export async function createSessionsScript(
  outputDir: string,
  aliasName: string,
): Promise<{ sessionsScript: string }> {
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true });
  }

  const sessionsScriptPath = join(outputDir, `${aliasName}-sessions.js`);

  await writeFile(sessionsScriptPath, generateSessionsBrowserScript(aliasName));
  await chmod(sessionsScriptPath, 0o755);

  return { sessionsScript: sessionsScriptPath };
}
